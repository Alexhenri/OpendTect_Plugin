<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpendTect-6_4: Threads Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="od_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpendTect-6_4
   &#160;<span id="projectnumber">6.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Threads Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>interface to threads that should be portable.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Atomic.html">Atomic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1AtomicPointer.html">AtomicPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classThreads_1_1Atomic.html">Atomic</a> instantiated with a pointer. The class really only handles the casting from a void* to a T*.  <a href="classThreads_1_1AtomicPointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Barrier.html">Barrier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a number of threads to reach a certain point (i.e. the call to <a class="el" href="classThreads_1_1Barrier.html#a3ea88e2c81cec18de40adb9891145725">Barrier::waitForAll</a>). Once everyone has arrived, everyone is released.  <a href="classThreads_1_1Barrier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1ConditionVar.html">ConditionVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an object that faciliates many threads to wait for something to happen.  <a href="classThreads_1_1ConditionVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Lock.html">Lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lock of a type that (hopefully) suits your needs. To use it, you need the <a class="el" href="classThreads_1_1Locker.html" title="Locks the lock, shutting out access from other threads if needed. ">Locker</a> class.  <a href="classThreads_1_1Lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Locker.html">Locker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the lock, shutting out access from other threads if needed.  <a href="classThreads_1_1Locker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Mutex.html">Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a lock that allows a thread to have exlusive rights to something.  <a href="classThreads_1_1Mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1MutexLocker.html">MutexLocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1ReadLockLocker.html">ReadLockLocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1ReadWriteLock.html">ReadWriteLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classThreads_1_1Lock.html" title="A lock of a type that (hopefully) suits your needs. To use it, you need the Locker class...">Lock</a> that permits multiple readers to lock the object at the same time, but it will not allow any readers when writelocked, and no writelock is allowed when readlocked.  <a href="classThreads_1_1ReadWriteLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1SpinLock.html">SpinLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an alternative to <a class="el" href="classThreads_1_1Mutex.html" title="Is a lock that allows a thread to have exlusive rights to something. ">Mutex</a>. It is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the lock is available. Because they avoid overhead from operating system process re-scheduling or context switching, spinlocks are efficient if threads are only likely to be blocked for a short period.  <a href="classThreads_1_1SpinLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the base class for all threads. Start it by creating it and give it the function or <a class="el" href="classCallBack.html" title="CallBacks object-oriented (object + method). ">CallBack</a> to execute.  <a href="classThreads_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1Work.html">Work</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstraction of something that can be done. It can be an ordinary <a class="el" href="classCallBack.html" title="CallBacks object-oriented (object + method). ">CallBack</a>, a static function (must return bool) or a TaskFunction on a CallBackerinheriting class, or a <a class="el" href="classTask.html" title="Generalization of something (e.g. a computation) that needs to be done in multiple steps...">Task</a>. The three examples are shown below.  <a href="classThreads_1_1Work.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1WorkManager.html">WorkManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes work and puts it on a queue for execution either in parallel, singlethread or manual.  <a href="classThreads_1_1WorkManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classThreads_1_1WriteLockLocker.html">WriteLockLocker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a115a7b2ee36e1b7e92c98cc8c6bafa6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a115a7b2ee36e1b7e92c98cc8c6bafa6e">atomicSetIfValueIs</a> (volatile int &amp;val, int curval, int newval, int *actualvalptr)</td></tr>
<tr class="separator:a115a7b2ee36e1b7e92c98cc8c6bafa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6953795acecb5d602302502a54aab05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#ae6953795acecb5d602302502a54aab05">getSystemNrProcessors</a> ()</td></tr>
<tr class="separator:ae6953795acecb5d602302502a54aab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4474ff81dd58845af4e3d5b4fe1e59d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a4474ff81dd58845af4e3d5b4fe1e59d8">getNrProcessors</a> ()</td></tr>
<tr class="separator:a4474ff81dd58845af4e3d5b4fe1e59d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f22fb9db14f1df42707e1f51d00b4df"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a5f22fb9db14f1df42707e1f51d00b4df">currentThread</a> ()</td></tr>
<tr class="separator:a5f22fb9db14f1df42707e1f51d00b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0e7430a3200dc95ef6a323f83df246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#aaf0e7430a3200dc95ef6a323f83df246">setCurrentThreadProcessorAffinity</a> (int cpu)</td></tr>
<tr class="separator:aaf0e7430a3200dc95ef6a323f83df246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbbc418e0570dbf3ea94c38d0f6d658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a9bbbc418e0570dbf3ea94c38d0f6d658">sleep</a> (double seconds)</td></tr>
<tr class="separator:a9bbbc418e0570dbf3ea94c38d0f6d658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cced8b6dc957a6d821c9426011adf8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a64cced8b6dc957a6d821c9426011adf8">lockSimpleSpinWaitLock</a> (volatile int &amp;lock)</td></tr>
<tr class="separator:a64cced8b6dc957a6d821c9426011adf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517e6038c3de6deb732fbe2ac758203a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a517e6038c3de6deb732fbe2ac758203a">lockSimpleSpinLock</a> (volatile int &amp;lock, <a class="el" href="classThreads_1_1Locker.html#a187ee26d7663e0cc221e6e4d3920255a">Locker::WaitType</a>)</td></tr>
<tr class="separator:a517e6038c3de6deb732fbe2ac758203a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bd1391116095bbf7999b89b8d4b90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceThreads.html#a43bd1391116095bbf7999b89b8d4b90c">unlockSimpleSpinLock</a> (volatile int &amp;lock)</td></tr>
<tr class="separator:a43bd1391116095bbf7999b89b8d4b90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>interface to threads that should be portable. </p>
<p>simple interface to thread locking</p>
<p>As usual, other thread systems are available but they are as far as we know simply too big and dependent.</p>
<p>The two ingredients are: The lock itself - commonly a class variable A locker (managing the setting and releasing of the lock)</p>
<p>Typical usage:</p>
<p>class X { ... <a class="el" href="classThreads_1_1Lock.html" title="A lock of a type that (hopefully) suits your needs. To use it, you need the Locker class...">Threads::Lock</a> datalock_; ... };</p>
<p>void X::doSomething() { <a class="el" href="classThreads_1_1Locker.html" title="Locks the lock, shutting out access from other threads if needed. ">Threads::Locker</a> locker( datalock_ ); for ( int i..... } </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a115a7b2ee36e1b7e92c98cc8c6bafa6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Threads::atomicSetIfValueIs </td>
          <td>(</td>
          <td class="paramtype">volatile int &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>curval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>actualvalptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<p>Atomically sets the 'val' only if its value is currently the value of 'curval'. If the value in 'val' is identical to the value of 'curval', function will change 'val' and return true. Otherwise, it will not change 'val', it will return false, and update the value at 'actualvalptr' to the current value of 'val'. </p>

</div>
</div>
<a class="anchor" id="a5f22fb9db14f1df42707e1f51d00b4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* Threads::currentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4474ff81dd58845af4e3d5b4fe1e59d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Threads::getNrProcessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6953795acecb5d602302502a54aab05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Threads::getSystemNrProcessors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches number of processors from operating system, unless: DTECT_USE_MULTIPROC is set to 'n' or 'N' The user settings contain a 'Nr Processors' entry. </p>

</div>
</div>
<a class="anchor" id="a517e6038c3de6deb732fbe2ac758203a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threads::lockSimpleSpinLock </td>
          <td>(</td>
          <td class="paramtype">volatile int &amp;&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classThreads_1_1Locker.html#a187ee26d7663e0cc221e6e4d3920255a">Locker::WaitType</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a64cced8b6dc957a6d821c9426011adf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Threads::lockSimpleSpinWaitLock </td>
          <td>(</td>
          <td class="paramtype">volatile int &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Any volatile integer that is initialized to 0 can act as a spinlock using this funciton. If you lock it, you have to unlock it by setting it to 0. Note that parallelStudio will report these as violations of thread-safety. Hence use thes only when standard locks cannot be used (e.g. static locks in functions). </p>

</div>
</div>
<a class="anchor" id="aaf0e7430a3200dc95ef6a323f83df246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threads::setCurrentThreadProcessorAffinity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the current thread to always run on a certain cpu. Set to -1 to remove binding. Not guaranteed to work on all platforms. </p>

</div>
</div>
<a class="anchor" id="a9bbbc418e0570dbf3ea94c38d0f6d658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threads::sleep </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the current thread to sleep </p>

</div>
</div>
<a class="anchor" id="a43bd1391116095bbf7999b89b8d4b90c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Threads::unlockSimpleSpinLock </td>
          <td>(</td>
          <td class="paramtype">volatile int &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr>
<p>Generated at <script type="text/javascript">document.write(document.lastModified);</script>
 for the <a href="http://www.opendtect.org">OpendTect</a>
seismic interpretation project.
Copyright (C): dGB Beheer B. V. 2019</p></body></html>
